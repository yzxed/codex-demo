<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>全新星空</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        background: radial-gradient(circle at top, #0b0f2e 0%, #04060f 45%, #010207 100%);
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        overflow: hidden;
        color: rgba(255, 255, 255, 0.85);
      }

      main {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
      }

      .nebula-layer {
        position: absolute;
        inset: -20%;
        background:
          radial-gradient(circle at 15% 30%, rgba(86, 121, 255, 0.25), transparent 55%),
          radial-gradient(circle at 85% 20%, rgba(255, 118, 185, 0.2), transparent 50%),
          radial-gradient(circle at 65% 70%, rgba(255, 214, 140, 0.16), transparent 55%),
          radial-gradient(circle at 45% 60%, rgba(130, 255, 228, 0.12), transparent 60%);
        filter: blur(12px);
        opacity: 0.85;
        mix-blend-mode: screen;
        animation: nebulaDrift 22s ease-in-out infinite;
      }

      .vignette {
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 50% 45%, rgba(0, 0, 0, 0) 35%, rgba(0, 0, 0, 0.6) 70%, rgba(0, 0, 0, 0.9) 100%);
        pointer-events: none;
      }

      .label {
        position: absolute;
        bottom: 8vh;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        letter-spacing: 0.4em;
        text-transform: uppercase;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .label strong {
        display: block;
        font-size: 1.6rem;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.9);
        margin-bottom: 0.3rem;
      }

      @keyframes nebulaDrift {
        0%,
        100% {
          transform: translate(0, 0) scale(1);
        }
        50% {
          transform: translate(4%, -3%) scale(1.05);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="nebula-layer"></div>
      <canvas id="stars"></canvas>
      <canvas id="meteors"></canvas>
      <div class="vignette"></div>
      <div class="label">
        <strong>STAR OCEAN</strong>
        全新深空星海
      </div>
    </main>

    <script>
      const starCanvas = document.getElementById("stars");
      const meteorCanvas = document.getElementById("meteors");
      const starCtx = starCanvas.getContext("2d");
      const meteorCtx = meteorCanvas.getContext("2d");

      const backgroundCanvas = document.createElement("canvas");
      const backgroundCtx = backgroundCanvas.getContext("2d");

      const layers = [
        { amount: 180, speed: 0.05, size: [0.4, 1.2] },
        { amount: 110, speed: 0.08, size: [0.7, 2.0] },
        { amount: 60, speed: 0.12, size: [1.2, 3.0] },
      ];

      const starPalette = [
        "255, 255, 255",
        "255, 244, 225",
        "198, 218, 255",
        "255, 205, 235",
      ];

      const stars = [];
      const meteors = [];

      const randomInRange = (min, max) => min + Math.random() * (max - min);

      const makeStar = (layer) => {
        const [minSize, maxSize] = layer.size;
        return {
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          radius: randomInRange(minSize, maxSize),
          alpha: randomInRange(0.3, 0.95),
          flicker: randomInRange(0.004, 0.018),
          phase: Math.random() * Math.PI * 2,
          speed: layer.speed,
          color: starPalette[Math.floor(Math.random() * starPalette.length)],
        };
      };

      const paintMilkyWay = () => {
        backgroundCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
        const { innerWidth, innerHeight } = window;

        backgroundCtx.save();
        backgroundCtx.translate(innerWidth * 0.5, innerHeight * 0.5);
        backgroundCtx.rotate(-0.35);
        const band = backgroundCtx.createLinearGradient(-innerWidth, 0, innerWidth, 0);
        band.addColorStop(0, "rgba(255,255,255,0)");
        band.addColorStop(0.35, "rgba(150,190,255,0.08)");
        band.addColorStop(0.55, "rgba(255,240,210,0.12)");
        band.addColorStop(0.75, "rgba(150,190,255,0.08)");
        band.addColorStop(1, "rgba(255,255,255,0)");
        backgroundCtx.fillStyle = band;
        backgroundCtx.fillRect(-innerWidth, -innerHeight * 0.15, innerWidth * 2, innerHeight * 0.3);
        backgroundCtx.restore();

        for (let i = 0; i < 320; i += 1) {
          const x = Math.random() * innerWidth;
          const y = Math.random() * innerHeight;
          const radius = randomInRange(0.2, 1.6);
          backgroundCtx.beginPath();
          backgroundCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.08})`;
          backgroundCtx.arc(x, y, radius, 0, Math.PI * 2);
          backgroundCtx.fill();
        }

        for (let i = 0; i < 40; i += 1) {
          const x = Math.random() * innerWidth;
          const y = Math.random() * innerHeight;
          const radius = randomInRange(50, 160);
          backgroundCtx.beginPath();
          backgroundCtx.fillStyle = `rgba(120, 150, 255, ${Math.random() * 0.05})`;
          backgroundCtx.arc(x, y, radius, 0, Math.PI * 2);
          backgroundCtx.fill();
        }
      };

      const resize = () => {
        const ratio = window.devicePixelRatio || 1;
        [starCanvas, meteorCanvas, backgroundCanvas].forEach((canvas) => {
          canvas.width = window.innerWidth * ratio;
          canvas.height = window.innerHeight * ratio;
        });
        [starCtx, meteorCtx, backgroundCtx].forEach((ctx) => ctx.setTransform(ratio, 0, 0, ratio, 0, 0));

        stars.length = 0;
        layers.forEach((layer) => {
          for (let i = 0; i < layer.amount; i += 1) {
            stars.push(makeStar(layer));
          }
        });

        paintMilkyWay();
      };

      const drawStars = (time) => {
        starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
        starCtx.drawImage(backgroundCanvas, 0, 0, window.innerWidth, window.innerHeight);

        stars.forEach((star, index) => {
          star.phase += star.flicker;
          star.y += star.speed;
          if (star.y > window.innerHeight + 12) {
            stars[index] = makeStar({ speed: star.speed, size: [star.radius * 0.6, star.radius * 1.4] });
            stars[index].y = -10;
          }

          const alpha = star.alpha + Math.sin(star.phase + time * 0.001) * 0.25;
          starCtx.beginPath();
          if (star.radius > 2.2) {
            starCtx.shadowBlur = 10;
            starCtx.shadowColor = `rgba(${star.color}, 0.35)`;
          } else {
            starCtx.shadowBlur = 0;
          }
          starCtx.fillStyle = `rgba(${star.color}, ${Math.max(0.12, alpha)})`;
          starCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          starCtx.fill();
        });
        starCtx.shadowBlur = 0;
      };

      const spawnMeteor = () => {
        if (meteors.length > 3) return;
        const startX = randomInRange(window.innerWidth * 0.2, window.innerWidth * 0.8);
        const startY = randomInRange(window.innerHeight * 0.1, window.innerHeight * 0.4);
        const length = randomInRange(220, 380);
        const angle = randomInRange(Math.PI * 1.1, Math.PI * 1.35);
        meteors.push({
          x: startX,
          y: startY,
          length,
          angle,
          speed: randomInRange(10, 16),
          life: 0,
        });
      };

      const drawMeteors = () => {
        meteorCtx.clearRect(0, 0, meteorCanvas.width, meteorCanvas.height);
        meteors.forEach((meteor, index) => {
          meteor.life += 1;
          meteor.x += Math.cos(meteor.angle) * meteor.speed;
          meteor.y += Math.sin(meteor.angle) * meteor.speed;

          const gradient = meteorCtx.createLinearGradient(
            meteor.x,
            meteor.y,
            meteor.x - Math.cos(meteor.angle) * meteor.length,
            meteor.y - Math.sin(meteor.angle) * meteor.length,
          );
          gradient.addColorStop(0, "rgba(255,255,255,0.8)");
          gradient.addColorStop(1, "rgba(255,255,255,0)");

          meteorCtx.strokeStyle = gradient;
          meteorCtx.lineWidth = 2;
          meteorCtx.beginPath();
          meteorCtx.moveTo(meteor.x, meteor.y);
          meteorCtx.lineTo(
            meteor.x - Math.cos(meteor.angle) * meteor.length,
            meteor.y - Math.sin(meteor.angle) * meteor.length,
          );
          meteorCtx.stroke();

          if (meteor.life > 40) {
            meteors.splice(index, 1);
          }
        });
      };

      let lastMeteor = 0;
      const animate = (time) => {
        drawStars(time);
        drawMeteors();
        if (time - lastMeteor > 2500 + Math.random() * 3000) {
          spawnMeteor();
          lastMeteor = time;
        }
        requestAnimationFrame(animate);
      };

      window.addEventListener("resize", resize);
      resize();
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
